## 1. 概述
  TCP(Transmission Control Protocol) 提供一种面向连接的, 可靠的字节流., 全双工的服务, TCP 位于简化的OSI网路模型中第四层中的传输层, 位于TCP/IP协议栈的第二层(传输层)



## 2. 首部

  	不计任选字段, 总共**20字节**

|    16位源端口      |   16位目标端口号   |
| ---- | ---- |
|      32位序号(SEQ 32bit无符号整数, 最高2^32 - 1 后又从0开始)     ||
| 32位确认序号(ack = SEQ + 长度) |      |
| 4位首部长度, 保留6位 | URG/ACK/PSH/RST/SYN/FIN/ 16位窗口大小 |
|   16位检验和                          |  16位紧急指针    |
|     选项  |      |
|    数据  |      |

① URG：当URG=1时，注解此报文应尽快传送，而不要按本来的列队次序来传送。与“紧急指针”字段共e同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长。
② ACK：**只有当ACK=1时，确认序号字段才有效；**
③ PSH：当PSH=1时，接收方应该尽快将本报文段立即传送给其应用层。
④ RST：当RST=1时，表示出现连接错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接；
⑤ SYN：SYN=1,ACK=0时表示请求建立一个连接，携带SYN标志的TCP报文段为同步报文段；
⑥ FIN：发端完成发送任务, 需要关闭连接。

## 建立连接


![  三次握手 ](/home/halo/picture/tcp三次握手.webp)

 1. SYN_SENT:  客户端主动发送**带有随机SEQ, ACK=0, SYN= 1**的**空报文段**给被动连接的服务端, 然后进入此状态. TCP规定, 此报文不得携带数据, 并且需要消耗一个序号, 此序号叫做初始序列号(ISN).  **随机选择序号的目的在于防止在网络中被延迟的分组在以后又被传送,而导致某个连接的一方对它作错误的解释。这样可以确保安全性与健壮性, 也防御TCP序号攻击** 

    **序号预测攻击[通过预测服务端的SYN跳过第二次握手, 以直接进入第三次握手建立连接]** 

 2. SYN_RCVD: 服务端在收到客户端发来的SYN请求报文进入此状态. 然后发送一个**带有随机SEQ, SYN=1, ACK= 1,确认号等于连接请求的序号加一**的确认报文给客户端以告知以收到连接请求. 此报文不能携带数据. (这里开始分配数据缓存, 可能受到到syn泛洪攻击(Ddos))

 3. EST:  当客户端收到服务端的确认报文后, 再进行第三次握手(**发送一个ack=第二次握手SEQ + 1**)并进入EST状态, 即可以开始传输.

    而服务端必须还要收到客户端的确认报文才可以进入EST状态. 此时若服务端在一定时间内没有收到客户端的第三次握手, 则进入超时状态, 并且再次进行第二次握手, 在linux下会重试五次, 从1s开始, 每次进行翻倍, 一共可超时31秒(1 + 2 + 4 + 8 + 16s), 第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。

4. **为什么要进行三次握手:  因为服务端需要第三次握手来确认客户端还要连接. 若客户端在第一次握手时发出的SYN报文延迟了, 客户端选择不再连接, 但是服务端在一段时间后收到第一次报文会以为客户端还要连接, 并发出第二次握手, 此时若没有第三次握手, 服务器就已经建立TCP连接, 等待客户端传数据过来, 但是已经客户端都掉线了, 那么服务器就会一直等待, 而如果采用第三次握手, 发送等于连接请求的序号加一的确认报文给客户端以告知以收到连接请求. 此报文不能携带数据.  客户端也需要给该连接分配缓存和变量那么服务器就可以设置一个超时时间, 若在超时时间内没有第三次握手进行确认, 那么则可以认为客户端此时并不要连接, 可以丢弃这个连接了.**  

5. ####  客户端正在和服务端建立 TCP 连接，然而当服务器变 SYN-RCVD 后，此时一个旧的 SYN 报文 又到达了，服务器会如何处理？     服务器此时判断不了这个SYN报文是不是旧的, 只能照样应答, 但是客户端会发送一个RST重置服务器为LISTEN状态, 

6. 最大报文长度MSS(Maximum Segment Size):  可选字段, 设置在头部的选项字段中, 一般在第一次握手时设置, 表示本方可接受的最大报文长度.

7. SYN泛洪(tcp flood)攻击:，就是利用`SYNACK 报文`的时候，服务器会为客户端请求分配缓存，那么黑客（攻击者），就可以使用一批虚假的`ip`向服务器大量地发建立`TCP 连接`的请求，服务器为这些`虚假ip`分配了缓存后，处在`SYN_RCVD`状态，存放在`半连接队列`中；另外，服务器发送的请求又不可能得到回复（ip都是假的，能回复就有鬼了），只能不断地`重发请求`，直到达到设定的时间/次数后，才会关闭。服务器不断为这些`半开连接`分配资源（但从未使用），导致服务器的连接资源被消耗殆尽，不过，我们可以使用`SYN Cookie`, `syncache`进行有效地防御。

8. 随机序号预测攻击: 一个黑客伪装成客户机向服务端发送请求, 然后使服务端无法接受, 并且还要发送多次第一次握手来获得随机序号并进行预测(因为第二次握手还是发给客户机的), 在预测后可以通过直接向服务端发送第三次握手来进入est状态

9. **第三次握手是可以携带数据的，而前两次不行。**


## 连接终止

![](/home/halo/picture/tcp四次握手.png)

1. FIN_WAIT_1: 客户端主动发出第一次挥手(**发送一个FIN =1, SEQ=最后一个字节序号+ 1的报文, 此报文不携带数据, 但是消耗一个序号**), 客户端进入此状态,等待服务器确认.
2. CLOSE_WAIT:  服务端收到第一次挥手后然后第二次挥手后(**发送一个ACK = 1, ack=第一次挥手序列 + 1 的确认报文**)进入此状态, 此状态下服务端可能仍有数据要发送, 客户端只能接受数据但不能再发送(除了确认报文), 此为**半关闭** 状态.
3. FIN_WAIT_2: 客户端收到服务端的第二次确认挥手 后进入此状态, 此时客户端已经进入半关闭状态(只能收不能主动发), 此时等待服务器传输剩余数据
4. LAST_ACK: 服务端的剩余数据已经全部发送完毕, 发送第三次挥手(**FIN=1, ACK=1,  seq=最后一个序号加一**)以告知客户端没有数据要传输了, 然后等待客户端进行确认, 然后才可以关闭且立即 关闭.
5. TIME_WAIT: 客户端收到第三次挥手后了解到没有数据需要接收了, 于是发送第四次挥手(**ACK=1, ack=第三次挥手序号 + 1 **) 以告知服务端客户端已经关闭. 但此时客户端仍为关闭, 还要超时2MSL此状态又叫**2MSL**状态, MSL为**报文最大生存时间**(以IP的TTL最大跳数为基准), **等待2MSL是为了尽全力确保服务端已经收到关闭连接的确认, 这样可让TCP再次发送最后的ACK以防这个ACK丢失(另一端超时并重发最后的 FIN),** **在此状态内, 客户端的此端口无法被占用, 且可能收到第三次挥手, 此时说明第四次挥手丢包. 则再次挥手, 重新计时** . 
6. **为什么需要四次挥手: 第一, 为了在半关闭状态下, 可以收到对方剩余数据发送完成的通知**关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 **第二，防止**已失效的连接请求报文段**出现在新的连接中。**客户端在发送完最后一个`ACK 报文`后，再经过时间`2MSL`，就可以使由于网络不通畅产生的滞留报文段失效。这样下一个新的连接中就不会出现旧的连接请求报文。

## 流量控制

目的: 流量控制用来避免主机分组发送得过快而使接收方来不及完全收下，一般由接收方通告给发送方进行调控(通过tcp首部的win字段)

概述: TCP使用**滑动窗口**协议实现流量控制。接收方在“接收窗口”域指出还可接收的字节数量。发送方在没有新的确认包的情况下至多发送“接收窗口”允许的字节数量。接收方可修改“接收窗口”的值。

窗口合拢: 左端向右端靠近, 发生在接收方接收到数据时

窗口张开: 右端向右边扩张, 发生在接收方读取完tcp缓存时

窗口左移: 不经常发生,

**当窗口值变为0时, 发送方必须停止发送数据, 并开始 保持定时器(persist timer) 以避免因随后的修改接收窗口的数据包丢失使连接的双侧进入死锁，发送方无法发出数据直至收到接收方修改窗口的指示。当“保持定时器”到期时，TCP发送方尝试恢复发送一个小的ZWP包（Zero Window Probe），期待接收方回复一个带着新的接收窗口大小的确认包。一般ZWP包会设置成3次，如果3次过后还是0的话，有的TCP实现就会发RST把链接断了 **

+ 窗口太小会对服务端造成较大开销,  造成**愚蠢窗口综合征**, 此时需要服务端等到有较大window size时才发送数据.

+ 接收端使用David D Clark算法：如果收到的数据导致window size小于某个值，可以直接ack把window给关闭了，阻止了发送端再发数据。等到接收端处理了一些数据后windows size大于等于了MSS，或者接收端buffer有一半为空，就可以把window打开让发送端再发数据过来。
+ 发送端使用Nagle算法来延时处理，条件一：Window Size>=MSS 或是 Data Size >=MSS；条件二：等待时间或是超时200ms，这两个条件有一个满足，才会发数据，否则就是在积累数据。Nagle算法默认是打开的，所以对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性程序，需要关闭这个算法。可以在Socket设置TCP_NODELAY选项来关闭这个算法。

## 拥塞控制

当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。
**拥塞窗口(congestion window) 记为cwnd**: **拥塞窗口是发送方使用的流量控制,而通告窗口(window size)则是接收方使用的流量控制.** 在某些点上可能达到了互联网的容量,于是中间路由器开始丢弃分组。这就通知发送方
它的拥塞窗口开得过大。

1. #### 慢启动(指数增长):
与另一个网络的主机建立TCP连接时,拥塞窗口被初始化为1个报文段(即另一端通告的报文段大小)。每收到一个ACK,拥塞窗口就加倍( cwnd以字节为单位,但是慢启动以报文段大小为单位进行增加, 仍需要考虑接受方的窗口)。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。在某些点上可能达到了互联网的容量,于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开得过大。

2. #### 拥塞避免(线性增长):
拥塞避免算法和慢启动算法需要对每个连接维持两个变量:一个拥塞窗口 cwnd和一个慢启动门限ssthresh。这样得到的算法的工作过程如下:
1) 对一个给定的连接,初始化 cwnd为1个报文段, ssthresh为65 535个字节。
2) TCP输出例程的输出不能超过 cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制,而滑动窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计,而后者则与接收方在该连接上的可用缓存大小有关。
3) 当拥塞发生时(超时或收到重复确认),**ssthresh被设置为当前窗口大小的一半(cwnd和接收方通告窗口大小的最小值,但最少为 2个报文段)。此外,如果是超时引起了拥塞,则cwnd被设置为1个报文段(这就是慢启动)**。
4) 当新的数据被对方确认时,就增加cwnd,但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。**如果cwnd小于或等于ssthresh(超时时, cwnd=1),则正在进行慢启动,否则正在进行拥塞避免。**慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止(因为我们记录了在步骤2中给我们制造麻烦的窗口大小的一半),然后转为执行拥塞避免。
**慢启动算法初始设置cwnd为1个报文段,此后每收到一个确认就加倍。**
**拥塞避免算法要求每次收到一个确认时将cwnd增加1**
**遇到拥塞时: cwnd = cwnd + (segsize ^ 2) / cwnd + segsize / 8 **

3. #### 快速重传与快速恢复:
    原因: 到在收到一个失序的报文段时, TCP立即需要产生一个ACK(一个重复的ACK)。这个重复的ACK不应该被迟延。该重复的ACK的目的在于让对方知道收到一个失序的报文段,并告诉对方自己希望收到的序号。由于我们不知道一个重复的ACK是由一个丢失的报文段引起的,还是由于仅仅出现了几个报文段的重新排序,因此我们等待少量重复的 ACK, 假如这只是一些报文段的重新排序,则在重新排序的报文段被处理并产生一个新的ACK之前,只可能产生1 ~2个重复的 ACK。如果一连串收到 3个或3个以上的重复 ACK,就非常可能是一个报文段丢失了.于是我们就重传丢失的数据报文段,而无需等待超时定时器溢出。
    过程: 
    1) 当收到第3个重复的 ACK时,**将ssthresh设置为当前cwnd的一半,** 然后**设置**cwnd为3倍的报文段大小加上ssthresk**的报文段大小。(,但是在接收到重复ACK的过程中cwnd允许保持增加,这是因为每个重复的ACK表示1个报文段已离开了网络(接收TCP已缓存了这个报文段,等待所缺数据的到达)。这就是快速恢复算法。), 最后重传丢失的报文段。
    2) 每次**cwnd为3倍的报文段大小加上ssthresk**的报文段大小。(**,但是在接收到重复ACK的过程中cwnd允许保持增加,这是因为每个重复的ACK表示1个报文段已离开了网络(接收TCP已缓存了这个报文段,等待所缺数据的到达)。这就是快速恢复算法。**), 最后重传丢失的报文段。
    2) 每次收到另一个重复的ACK时, cwnd增加1个报文段大小并发送1个分组(如果新的cwnd允许发送)。
    3) **当下一个确认新数据的 ACK到达时,设置cwnd为ssthresh**(在第1步中设置的值)。这个ACK应该是在进行重传后的一个往返时间内对步骤 1中重传的确认。另外,这个ACK也应该是对丢失的分组和收到的第 1个重复的AC K之间的所有中间报文段的确认。**这一步采用的是拥塞避免,因为当分组丢失时我们将当前的速率减半。**



## 路由器/交换机/三层交换机

1. ### 交换机:

   - 是一种网络硬件，通过报文交换接收和转发数据到目标设备，它能够在计算机网络上连接不同的设备. 

   - 工作在第二层网路链接层

   - 因此交换机可用于划分数据链路层广播，即冲突域(冲突域中所有节点都链接到同一个被交换机和学习型网桥划分的相互连接的中继器集合)；但它不能划分网络层广播，即广播域(广播域中的任意一个节点可以在数据链路层通过广播的方式到达任意一个节点。)。

   - 冲突域一般小于或包含在广播中, 但是广播域只能由路由器划分

   - 工作方式:

     - 收到某网段（设为A）MAC地址为X的计算机发给MAC地址为Y的计算机的数据包。交换机从而记下了MAC地址X在网段A。这称为学习（learning）。
     - 交换机还不知道MAC地址Y在哪个网段上，于是向除了A以外的所有网段转发该数据包。这称为泛洪（flooding）。
     - MAC地址Y的计算机收到该数据包，向MAC地址X发出确认包。交换机收到该包后，从而记录下MAC地址Y所在的网段。
     - 交换机向MAC地址X转发确认包。这称为转发（forwarding）。
     - 交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包。这称为过滤（filtering）。
     - 交换机内部的MAC地址-网段查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。

     对于全交换（full-switch）局域网，交换机每个端口只连接一台

2. ### 三层交换机:

   三层交换机则可以处理第三层网络层协议，用于连接不同[网段](https://zh.wikipedia.org/wiki/网段)，通过对缺省[网关](https://zh.wikipedia.org/wiki/网关)的查询学习来创建两个网段之间的直接连接。

   三层交换机可以实现路由器的全部或部分功能，但只能用于同一类型的局域网子网之间的互连。这样，三层交换机可以像二层交换机那样通过MAC地址标识数据包，也可以像传统路由器那样在两个局域网子网之间进行功能较弱的路由转发，它的路由转发不是通过软件来维护的路由表，而是通过专用的ASIC芯片处理这些转发；

3. ### 路由器:
- 连接两个及以上的设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进S行），这称为转送。
- 交换机泛指工作于任何网络层次的数据中继设备（尽管多指网桥)，而路由器则更专注于网络层。
- RIP协议: 每隔30秒会与相邻的路由器交换信息, 以动态创建路由表
- ARP协议: 根据目的主机的IP地址，获得其MAC地址(通过广播ARP包)

4. #### 路由器, 交换机区别:

   1. 路由器工作在OSI第三层(网络层), 交换机工作在第二层(链路层)
   2. 路由器提供IP->MAC的映射, 交换机提供MAC->交换机端口的映射
   3. 路由器除了有交换机功能, 还有路由功能, 用于选择最佳路径

