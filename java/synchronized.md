# synchronized

1. ### 实现原理:
JVM基于进入和退出Monitor对象来实现方法同步, 在代码前后插入monitorenter和monitorexit实现的
  - 对于普通方法, 锁是当前实例
  - 对于静态方法, 锁是当前类的Class对象
  - 对于同步方法块, 锁是括号里的对象

2. ### 对象头:
synchronized锁是存在对象头中的, **若对象是数组, 用3个字存储对象头, 若是普通对象, 则用2个字存储对象头**

3. ### 锁的升级
  1. 偏向锁: 当不存在锁竞争时, 为了让线程获得锁的代价更低.
     - **当一个线程访问同步块并获取锁时, 会在对象头和栈帧中的锁记录存储偏向的线程ID, 以后该线程进入和退出同步块就不用CAS来加解锁, 只需在mark word里面测试一下是否存储着当前线程ID, 如果测试成功, 则线程已经持有锁, 若没有, 则要测试一下mark word中偏向锁标志是否设置为1, 如果没有, 则用cas竞争锁, 如果设置了, 则尝试使用cas将偏向锁改为当前线程.**
     - **当有锁竞争时, 偏向锁才会释放: 它会等到安全点, 然后暂停拥有偏向锁的线程并测试其状态, 若线程已死, 则设置成无锁状态, 若仍存活, 则偏向其它线程, 或恢复到无锁或者升级**
  2. 轻量级锁:
     - 加锁: 在线程执行同步块时, 会将对象头复制到栈, 称为锁记录(Displaced mark word), 然后通过cas将对象头的mark word替换为当指向锁记录的指针, 若成功, 则当前线程获得锁, 若失败, 则自旋重试.
     - 解锁: 解锁时, 会用cas将displaced mark word 替换会对象头, 如果成功, 则没有竞争, 若失败, 则当前有锁竞争, 升级到重量级锁.
  3. 重量级锁: 
     因为自旋会消耗CPU, 所以一但锁升级到重量级锁, 便不会恢复到轻量级锁. 在重量级锁状态下, 其他线程要获取此锁都要被阻塞住.

4. 锁场景:
  - 偏向锁: 适用于只有一个线程的场景
  - 轻量级锁: 追求响应时间, 竞争没那么激烈
  - 重量级: 追求吞吐量, 同步块执行速度较长, 竞争比较激烈
