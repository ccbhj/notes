# Java垃圾回收

1. ### 引用计数算法（Reachability Counting）
    1. 是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。
    2. 缺点: 回收分摊在运行时, **循环引用**
    
2. ### 可达性分析算法（Reachability Analysis）
    通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于 GC Root。

  - 虚拟机栈（栈帧中的本地变量表）中引用的对象(new 出来的)
  - 方法区的静态变量(static)
  - 方法区的常量(final)
  - 本地方法栈中JNI(本地方法)引用的对象

3. ### java内存区域: 
在 Java 语言中，可作为 GC Root 的对象包括以下4种：
    + 虚拟机栈（栈帧中的本地变量表）中引用的对象, 如函数中new出来的对象
    + 方法区中类静态属性引用的对象: static类型数据
    + 方法区中常量引用的对象: final 对象
    + 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象: 当调用的是本地方法时，虚拟机会保持 Java 栈不变，, 虚拟机只是简单地动态连接并直接调用指定的本地方法

4. ### 垃圾回收算法:
    1. #### 标记-清除算法（Mark-Sweep）
    是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。**但会产生许多内存碎片**
    2. #### 复制算法(Copying): 
    是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。** 内存只能用一半, 但极为浪费空间 ** 
    3. #### 标记-整理算法: 
    标记过程仍然与标记 --- 清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域. **解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多**
    4. #### 分代收集算法（Generational Collection) :
    对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。**在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 -- 整理算法来进行回收。**

5. ### 分代回收策略:
    Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构. **Java 堆主要分为2个区域-年轻代与老年代(Old区)，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。**
  1. #### Eden区: 

    大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC (**新生代的回收称为Minor GC**)，Minor GC 相比 Major GC (**老年代的GC称为Major GC**)更频繁，回收速度也更快。通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区)

  2. #### Survivor 区

    Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 区存活的对象复制到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区), 然后一次性清除Eden和From区。
     + 为啥需要 Survivor 区: Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。
     + 为啥需要From 和  TO 两个区域: 最大的好处就是**解决内存碎片化和对象提早进入老年代** 因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。**这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。
  3. #### Old区:

    老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，**每次 GC 都会触发“Stop-The-World”**。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，**所以老年代这里采用的是标记 --- 整理算法**。
    以下对象可直接进入老年代:
    
     + 大对象: 大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制
     + 长期存活的对象: 虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中没经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。
     + 3、动态对象年龄: 虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的综合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。

### 6. 什么时候进行回收? safepoint

  由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：

  + 循环的末尾
  + 方法返回前
  + 调用方法的 call 之后
  + 抛出异常的位置 

### 7.  垃圾回收器:



![](/home/halo/notes/java/垃圾回收器.png)

+ 在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge
+ 在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old
+ 同时在新老生代工作的垃圾回收器：G1



#### 新生代收集器

1. Serial: 

   单线程收集器, 适用于client模式,特点:

   - 简单有效
   - 单线程, 无线程上下文切换

2. ParNew: Serial

   收集器的多线程版本, 其他与Serial相似, 主要工作在server模式下,**唯一一个可以配合CMS工作的**

3. Parallel Scavenge: 

   和ParNew相似, 多线程, 使用复制算法, 但是 Parallel Scavenge **目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间））**，也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 **Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务**。

   Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）

#### 老年代收集器

1. Serial Old

   工作于老年代的单线程收集器，使用标记-整理算法,  此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用

2. Parallel Old 

   是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标

3. CMS

   CMS 收集器是以实现最短 STW 时间为目标的收集器，**使用标记-清除算法**, 如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！

   我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤

   1. 初始标记: 标记GC root关联的对象

   2. 并发标记: 进行GC root tracing,

   3. 重新标记: 修正前两个阶段没有标记的对象

   4. 并发清除: 

      ![](/home/halo/notes/java/CMS.webp)

   **初始标记和重新标记两个阶段会发生 STW**，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但**远比并发标记时间短**。

   **整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作**，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。

   但是有以下三个缺点:

   		- CMS 收集器对占用CPU资源
     - CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 **Concurrent Mode Failure** 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。
     - CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。

   

#### G1（Garbage First） 收集器

G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点

+ 像 CMS 收集器一样，能与应用程序线程并发执行。
+ 整理空闲空间更快。
+ 需要 GC 停顿时间更好预测。
+ 不会像 CMS 那样牺牲大量的吞吐性能。
+ 不需要更大的 Java Heap

与 CMS 相比，它在以下两个方面表现更出色

1. 运作期间不会产生内存碎片，**G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，**收集后提供规整的可用内存，这样有利于程序的长时间运行。
2. 在 STW 上建立了**可预测**的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。

为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器， G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址如下

![](/home/halo/notes/java/640.webp)

除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。

那么 G1 分配成这样有啥好处呢？传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。

G1 收集器的工作步骤如下

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收: 筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。