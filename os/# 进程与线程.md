# 进程与线程

### 1. 概念

1. 进程: 进程是由程序代码和相关数据以及进程控制块(Process Control Block)组成的程序实体。在操作系统中，一个任务就对应着一个进程，比如打开浏览器、开启QQ等。  process 主要包括
    - Code Section       
    - Data Section
    - OS Resource (文件/打印机等)
       - Code Section + Data Section = memory resource
2. 线程: 由进程分配资源并且运行在进程所拥有的地址空间中的一个程序任务。进程中所有的线程共享改进程的状态和资源，它们在同一块地址空间中，并且可以访问进程中相同的数据。同时，每个线程也拥有自己的栈存储数据

线程主要包括: 
- Stack
-  寄存器
- 程序计数器

### 2. 进程切换:

当前进程因时间片用完或者因等待某个事件而阻塞时，进程调度需要把处理器的使用权从当前进程交给另一个进程，这个过程叫做进程切换。

1. 切换时机:
      1. 外部中断: CPU以外的元件发出的中断(IO中断, 定时器, 键盘)
   2. 内部中断: stack overflow, divided by zero
   3. 软件中断: 比如system call (陷入内核)
2. 切换内容:
   1. **用户级上下文:** 正文、数据、用户堆栈以及共享存储区(切换页目录以使用新的地址空间)
   2. **寄存器上下文:** 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)
   3. **系统级上下文:** 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈
3. 上下文切换时，被调用进程成为当前进程。**在进程切换时系统要把当前进程的上下文保存在指定的内存区域（该进程的任务状态段TSS中），然后把下一个使用处理器运行的进程的上下文设置成当前进程的上下文。当一个进程经过调度再次使用CPU运行时，系统要恢复该进程保存的上下文。所以，进程的切换也就是上下文切换。**在系统内核为用户进程服务时，通常是**进程通过系统调用执行内核代码**，这时进程的执行状态由用户态转换为内核态。

### 3. 区别: 

1. 进程是资源分配的基本单位，而线程是调度的基本单位；
2. 进程与进程之间是独立的，一个进程的异常终止不会影响其它进程，而线程与线程之间大部分是共享的，一个线程的异常终止会影响其它线程，会使进程终止；
3. 线程与线程大部分共享，但是也有一部分数据私有，线程ID、上下文（切换时候寄存器中的值）、自己独享一个栈空间、错误码、信号屏蔽字、调度的优先级；
4. 调度和切换：线程上下文切换比进程上下文切换要快得多；
5. 一个进程中有多个线程时候，在进程与进程之间的切换所花费消耗的大于线程与线程之间切换的花销。
6. 线程比进程占用的资源要小，一个线程的创建消耗的资源远小于进程的创建；
7. 进程与进程之间是独立的，所以在并发过程中，用同步互斥少，相对安全，代码编写容易。线程之间大多数资源共享，所以往往要加上同步互斥锁；
8. 线程创建出来的线程是平等的没有上下级，而进程创建出进程就为该进程的子进程。
9. 进程本身不需要stack
10. 一个进程对应多个线程, 一个线程对应一个进程

### 4. 进程与线程之间的关系：

1. 线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中；
2. 一个线程的结束进程不一定会退出，但是进程的退出，线程将退出；
3. 一个进程中的多个线程共享：
   - 一个进程中线程与线程之间共虚拟地址空间；

   - 共享文件描述符

   - 每种信号的处理方式

   - 当前的工作目录

   - 用户ID和组ID

   - 进程资源，防止造成僵尸进程。而线程也要进行等待，释放线程的资源（除过线程的分离）。

### 5. 线程分类: 
1. 用户级线程: 在用户级线程软件中，线程的管理有应用程序完成，内核意识不到线程的存在。所有的线程都在进程的用户空间中，线程切换不需要内核态特权，线程的调度也有应用程序负责。当一个进程中的线程运行时产生阻塞操作，那么这个时候内核就会启动阻塞操作并把当前进程的状态置为阻塞态。
2. 内核级线程: 运行在内核级软件中，有关线程的管理在内核中完成，内核为进程及其内部的线程维护上下文信息，应用程序部分没有进行线程管理的代码。
3. 用户级线程和内核级线程的优缺点：
+ 用户级线程切换不需要内核切换状态，内核级线程切换需要内核切换状态。
+ 用户级线程可以在任何操作系统中运行，不需要修改底层内核。
+ 用户级线程阻塞时，也会阻塞当前进程和其他线程；内核级线程阻塞时不会阻塞当前进程和线程，并且可将控制权调度到另外一个线程。
+ 用户级线程的应用程序无法使用多核，一个进程只能分配给一个处理器；内核级线程的应用中，**内核可以将同一个进程中的多个线程分配到多个处理器**

### 6. Java中的线程:
一般来说，我们使用的Java线程是以1:1的形式映射到**轻量级进程**中去的。**轻量级进程**是通过内核程中的接口实现的，它和内核级线程也是1:1的关系，所以从根本上来说，Java线程是一种内核级线程。
1. 调度:
线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行。线程休眠的方法是Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)，均为静态方法，那调用sleep休眠的哪个线程呢？简单说，哪个线程调用sleep，就休眠哪个线程。
2. 优先级:
与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。setPriority(int priority);
3. 让步:
    线程的让步含义就是使当前运行着线程让出CPU资源，但是给谁不知道，仅仅是让出，线程状态回到可运行状态。线程的让步使用Thread.yield()方法，yield() 为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。
4. 合并:
    线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。join为非静态方法，定义如下：
    void join()：等待该线程终止。
    void join(long millis)：等待该线程终止的时间最长为 millis 毫秒。
    void join(long millis, int nanos)：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。
5. 守护线程
    守护线程与普通线程写法上基本没啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程使用的情况较少，但并非无用，举例来说，JVM 的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。
    
    

### 7. Java线程池

![](/home/halo/notes/java线程池.jpg)

1. 线程池的作用: 
	1. 降低资源消耗。线程是操作系统十分宝贵的资源，当多个人同时开发一个项目时，在互不知情的情况下，都自己在代码中创建了线程，这样就会导致线程数过多，而且线程的创建和销毁，在操作系统层面，需要由用户态切换到内核态，这是一个费时费力的过程。而使用线程池可以避免频繁的创建线程和销毁线程，线程池中线程可以重复使用。
	2. 提高响应速度。当请求到达时，由于线程池中的线程已经创建好了，使用线程池，可以省去线程创建的这段时间。
	3. 提高线程的可管理性。线程是稀缺资源，当创建过多的线程时，会造成系统性能的下降，而使用线程池，可以对线程进行统一分配、调优和监控。
2. 实现原理:
	
	1. 先判断线程池中线程的数量是否超过核心线程数，如果没有超过核心线程数，就创建新的线程去执行任务；如果超过了核心线程数，就进入到下面流程。
	2. 判断任务队列是否已经满了，如果没有满，就将任务添加到任务队列中；如果已经满了，就进入到下面的流程。
	3. 再判断如果创建一个线程后，线程数是否会超过最大线程数，如果不会超过最大线程数，就创建一个新的线程来执行任务；如果会，则进入到下面的流程。
	4. 执行拒绝策略。

3. 创建原理
```java
public ThreadPoolExecutor(int corePoolSize,
                      int maximumPoolSize,
                      long keepAliveTime,
                      TimeUnit unit,
                      BlockingQueue<Runnable> workQueue,
                      ThreadFactory threadFactory,
                      RejectedExecutionHandler handler) {
}
```
- corePoolSize：该参数表示的是线程池的核心线程数。当任务提交到线程池时，如果线程池的线程数量还没有达到corePoolSize，那么就会新创建的一个线程来执行任务，如果达到了，就将任务添加到任务队列中。
- maximumPoolSize：该参数表示的是线程池中允许存在的最大线程数量。当任务队列满了以后，再有新的任务进入到线程池时，会判断再新建一个线程是否会超过maximumPoolSize，如果会超过，则不创建线程，而是执行拒绝策略。如果不会超过maximumPoolSize，则会创建新的线程来执行任务。
- keepAliveTime：当线程池中的线程数量大于corePoolSize时，那么大于corePoolSize这部分的线程，如果没有任务去处理，那么就表示它们是空闲的，这个时候是不允许它们一直存在的，而是允许它们最多空闲一段时间，这段时间就是keepAliveTime，时间的单位就是TimeUnit。
- unit：空闲线程允许存活时间的单位，TimeUnit是一个枚举值，它可以是纳秒、微妙、毫秒、秒、分、小时、天。
- workQueue：任务队列，用来存放任务。该队列的类型是阻塞队列，常用的阻塞队列有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue等。 ArrayBlockingQueue是一个基于数组实现的阻塞队列，元素按照先进先出（FIFO）的顺序入队、出队。** 需要指定大小**
- threadFactory：线程池工厂，用来创建线程。通常在实际项目中，为了便于后期排查问题，在创建线程时需要为线程赋予一定的名称，通过线程池工厂，可以方便的为每一个创建的线程设置具有业务含义的名称。
handler：拒绝策略。当任务队列已满，线程数量达到maximumPoolSize后，线程池就不会再接收新的任务了，这个时候就需要使用拒绝策略来决定最终是怎么处理这个任务。默认情况下使用AbortPolicy，表示无法处理新任务，直接抛出异常。在ThreadPoolExecutor类中定义了四个内部类，分别表示四种拒绝策略。我们也可以通过实现RejectExecutionHandler接口来实现自定义的拒绝策略。AbortPocily：不再接收新任务，直接抛出异常。 CallerRunsPolicy：提交任务的线程自己处理。 DiscardPolicy：不处理，直接丢弃。 DiscardOldestPolicy：丢弃任务队列中排在最前面的任务，并执行当前任务。（排在队列最前面的任务并不一定是在队列中待的时间最长的任务，因为有可能是按照优先级排序的队列）

## 8. linux进程&线程

1. linux 中没有一个明确的进程或线程的概念, 用的是Task(aka. light-weight process). 用task_struct表示
    struct task_struct {
       volatile long state; // -1(unrunnable), 0 (runnable), 0  (stopped)
       void *stack;  // 用于存放临时变量
       struct mm_struct *mm // 内存管理, 描述整个虚拟内存地址空间(kernel thread中没有)
       struct thread_struct thread; // 存放上下文切换的信息
    }

2. 如果mm_struct是共享的, 那就是个线程, 如果mm_struct是自己生成的, 那就是一个进程, 本质是一个main thread(CPU调度的单位) 
    struct mm_struct {
      unsigned long start_stack; 
    }
    start_stack 是用户态的内存空间的起始(栈底), 这是属于进程的(所有线程共享).
    如果此 task 是一个线程, 为了不影响其他线程(mm_strcut中的stack), 父进程会在堆或者mmap内找一个空间作为线程的stack
    因此: 建立一个线程或者进程会产生两个stack:
    
    + 用户stack: 在thread结构中的stack, 是用户地址空间的一部分(mm_s tack中的一部分或者heap/mmap) 
    + 内核stack: 在task_struct中的stack
    
    
    
4. 创建线程比创建新进程成本低，因为新创建的线程使用的是当前进程的地址空间。相对于在进程之间切换，在线程之间进行切换所需的时间更少，因为后者不包括地址空间之间的切换。

4. 进程描述符大致(task_struct, PCB)包括:

    1. 调度参数: 优先级, 最近消耗cpu时间等
    2. 内存映射: 代码段, 数据段, 堆栈, 页表等
    3. 信号: 信号掩码
    4. 机器寄存器: 各种寄存器
    5. 系统调用状态: 当前系统调用的状态
    6. 文件描述符
    7. 统计数据: 拥有的最大堆栈大小, 可以消耗的页面数
    8. 内核堆栈: 内核部分的堆栈
    9. 其他: PID等

    

5. fork():

    fork创建一个和原始进程完全相同的进程副本, 包括相同的文件描述符, 寄存器内容和其他所有东西, 但是互相独立.

    **调用fork时:  陷入内核并且创建一个task_struct和相关结构(thread_struct), 然后分配PID, 然后复制父进程的代码段, 数据段(不和父进程共享), 但是内存其实没有复制, 而是使用了COW. 之后开始运行代码,调用exec系统调用,内核验证可执行文件, 然后建立页表与新的地址空间, 释放之后收到缺页中断会进行填充, 最后复制所有的参数, 变量等, 信号被重置, 寄存器清零**

6. clone(function, stack_ptr, sharing_flags, arg):

    2000年出现, **这个系统调用函数使linux模糊了线程和进程的区别, 使得用户可以设置进程和其中的线程哪些可以共享(依赖sharing_flags)**, 调用这个函数会创建新进程, 当新线程在当前进程中, 则地址是共享的, 而如果不是, 则复制新的地址空间(相当于fork). 新线程会执行function, 其私有栈指针被初始化为stack_ptr

    Linux下的线程实质上是轻量级进程(light weighted process),线程生成时会生成对应的进程控制结构，只是该结构与父线程的进程控制结构共享了同一个进程内存空间。 同时新线程的进程控制结构将从父线程（进程）处复制得到同样的进程信息，如打开文件列表和信号阻塞掩码等。

7. Linux的线程调度:

    线程分为3类:

    - 实时先进先出: 最高优先级, 不可被抢占
    - 实时轮转: 时间量用完会被抢占
    - 分时:  

    调度算法:

    1. O(1): 维护2个数组, 一个放正在活动的任务, 一个放时间片用完的任务. 调度器从活动数组中取一个任务, 若它时间片用完, 则放入过期数组, 当正在活动的数组为空, 则交换指针, 空的活动数组变为时间片过期数组. 但当一个线程阻塞, 在他时间片过完之前, 只要事件到了, 则可以重新进入活动数组

    2. CFS(完全公平调度器): 利用红黑树排序虚拟运行时间, 每次执行最左边的节点, 调度器周期性地递增其虚拟运行时间, 再重新取得最左边的节点

       通过控制其虚拟运行时间的递增速度来控制线程的优先级

8. Linux启动流程:

    1. BIOS加电自检
    2. 启动磁盘第一个扇区, 即主引导记录(MBR), 其中包含一个512字节的boot程序, 将其复制到内存的高地址, 从而释放操作系统低地址内存
    3. boot读取启动设备的根目录, 为了理解系统的文件目录格式, 需要用到引导程序(如GRUB)
    4. boot读入内核, 并把控制权给内核
    5. 内核数据结构得到分配, 系统开始自动配置
    6. 启动进程0, 建立堆栈, 运行它, 然后进行系统初始化: 配置实时时钟, 挂载根目录, 创建init进程

    