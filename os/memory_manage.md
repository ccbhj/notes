# 内存管理

### 一,不使用存储器抽象

​	在运行多个程序时, 存在多个程序引用地址错误(因为程序装载的顺序不同, 需要加下方程序的占用内存)的问题.

并且操作系统等重要软件的内存不安全.

解决方法: **静态重定位技术**--在装载程序时加上一个偏移量

 内存装载速度慢



### 二,使用存储器抽象:地址空间

###### 定义: 用于寻址内存的一套地址集合. 每个程序都有其自己的独立的地址空间

###### 问题: 每个程序有自己的地址空间,一个程序中的地址28所对应的物理内存与另一个程序中的地址28所对应的不同

解决方法: **动态重定位**技术, 用基址寄存器和界限寄存器, 分别记录程序的起始位置与大小

缺点:每次都要进行加法与比较运算



### 三, 交换技术

解决问题,目的: 内存不够用

交换技术: 把一个程序调入内存,运行一段时间后再存回磁盘

问题一: 存在**内存空洞**

解决: **内存紧缩** 将所有内存合并

缺点: 耗费大量CPU时间

问题二: 内存分配时需要考虑程序的**增长空间**

解决: 交换别的程序出去



### 四, 空闲内存管理

###### 1, 使用位图: 用1,0表示占用/空闲

此时需要考虑内存单位大小,这影响位图的控制粒度大小,单位越大,位图越小,控制粒度越粗.

问题: 分配内存时需要遍历查询位图, 耗时间

###### 2, 用链表:每个节点保持空闲区或进程标志, 起始地址, 长度, 下个节点指针

### 五, 链表内存分配策略:

##### 1, 首次适配: 遍历链表, 直到找到足够大的内存

​	特点: 快, 但是利用率不高

##### 2, 下次适配: 记录此次内存分配位置, 以便在下次遍历时从这里开始

遍历

​	特点: 性能略低于首次适配

###### 3, 最佳适配: 遍历整个链表,找出能适配的**最小**内存区

​	特点: 慢,产生许多碎片内存, 利用率不高

最差适配:总是分配最大的内存

为空闲区与进程区单独维护两个链表, 并按照大小排序,可提高最佳适配的速度

##### 5, 最佳适配: 为常用的空闲区维护单独的链表

​	特点: 寻找特定大小内存块时比较快,然而在内存终止或换出时合并内存十分耗时



 

### 六, 虚拟内存

#### 1,基本概念

​	1,定义:  每个程序拥有自己的内存空间, 并被分为多个块, 每个块叫做一个**页面**, 每一页有连续的地址范围. 这些页被映射到物理内存,**但并不是所以的页必须在内存中才能运行程序**. 虚拟内存抽象了应用程序物理内存的细节，只允许物理内存保存所需的信息（按需分页），并提供了一种保护和控制进程间数据共享数据的机制。有了虚拟内存机制之后，每次访问可以使用更易理解的虚拟地址，让CPU转换成实际的物理地址访问内存，降低了直接使用、管理物理内存的门槛。

​	2,原理: 当程序需要引用到在物理内存中的页时, 由**硬件**来进行映射, 当引用空间不在物理内存时, 由**操作系统**将缺失部分装入物理内存并重新执行失败的指令.  物理内存按大小被分成页框、页，每块物理内存可以被映射为一个或多个虚拟内存页。这块映射关系，由操作系统的页表来保存，页表是有层级的。层级最低的页表，保存实际页面的物理地址，较高层级的页表包含指向低层级页表的物理地址，指向顶级的页表的地址，驻留在寄存器中。当执行地址转换时，先从寄存器获取顶级页表地址，然后依次索引，找到具体页面的物理地址。

###### 	3, **目的**: 解决了虚拟内存的装载不够灵活的问题, 同时也让物理内存得以“扩大”.	

​	4.  **虚拟地址**: 程序产生的地址, 并构成一个虚拟空间

​	5. **内存管理单元(MMU)**: 将虚拟地址映射为物理地址

​	6, **页框**: 物理空间的分页, 大小一般和内存页面一样

​	7, **缺页错误(page fault)**:MMU注意到页面没有被映射到物理内存页中, 就会引发此错误(即在/不在位为0时)

​	8, **页表**: 将虚拟页面映射为页框. 虚拟地址可被分为虚拟页号(高位)和偏移量(底位部分).

​	页号: 可作为索引来找到虚拟页面对应的页框

​	**页表是一个函数, 输入是虚拟页号, 输出是物理页框号**

###### 	9, 页表项: 高速缓冲禁止位 + 访问权限位 + 修改位 + 保护位 + 在/不在位 + 页框号

#### 2, 加速分页进程

1. 转换检测缓冲区: 设置一个小型硬件设备, 将虚拟地址直接映射到物理地址, 而不必去页表里查找

   又称为**快表**, **相联存储器**  

2. 软件TLB管理

#### 3,针对大内存页表:

1. **多级页表**: 
   + 原因: 避免将所有页表一直保存在内存中
   + 工作原理: 将一个地址分为三个部分(以二级页表为例): PT1 +  PT2 + Offset, 其中PT1为第一页页表索引, PT2为第二级页的索引, offset为目标块内地址.
2. **倒排页表**:
   + 原理: 实际内存中的每个页框(物理内存块)对于一个虚拟页面, 而不是每个页面对应一个页表项.

#### 4, 页面置换算法:

 **注意: 以下说的页面都是保持在内存中的, 即页框**

+ 作用: 当发生缺页中断时,操作系统必须从内存中将一个页面置换出去,为新页面腾出空间.若换出页面已被修改, 则需写入磁盘, 否则直接覆盖.
+ **最优页面置换算法**: 给每个页面一个在首次被执行前需要执行的指令数作为标记, 此算法便是要置换出指令数标记最大的, 即将较晚访问的页面置换出去
  + 缺点: 无法实现, 操作系统无法知道在页面第一次给访问前还有多少指令未执行, 并且性价比低.
  + **此算法不实用**
+ **最近未使用算法(NRU)**: 系统为每个页面设置两个状态位R与M位, 一被读写便将R置1, 一被修改便将M置1, 一旦被置1, 就会一直保持到操作系统将它复位.
  
  + 原理: 操作系统定期的将R位置0, 以区分没有被访问和有被访问的页面. 每次置换时优先置换没被修改没被访问的, 然后是被修改没被访问的, 没被修改的被访问的, 被访问的被修改的是优先级最低. 
+ **先进先出算法(FIFO)**: 操作系统维护一个链表, 新进入的放在表尾, 晚进的放表头, 淘汰表头
+ **二次机会算法(second chance)**: 设置一个标志位, 如果该页面被访问过置为1, 没访问则保持0, 在淘汰表头时检查此位,若为0, 立即淘汰, 若为1, 则将它放回表后, 并置0.
+ **时钟页面置换算法**: 将页面排成一个环形链表, 一个表针指向最老的页面, 淘汰时检查表针指向的页面的R位, 若为1则置0并前移, 若为0则直接淘汰
+ **最近最少使用算法(LRU)**: 为每个页维护一个计数器, 在发生缺页中断时, 置换计数器值最小的.(性能低)
  
  + 优化后的算法--老化(aging) : 用连续的几个位代替计数器, 每次时钟中断时, 几个位右移后再加上R位, 每次置换时置换最小的页面
+ **工作集页面**:
  + 问题: 在进程刚启动时因为内存里没有页面会引发许多缺页中断, 因为这种方式是**请求调页**, 页面是在需要时调入, 而不是预先调入. 多道程序设计系统中, 进程会调出调入, 这种缺陷会体现更明显.
  + **工作集**: 最近k次内存访问过的页面的集合为工作集, 操作系统只需要预先设定一个k.或者设定一个时间t, 工作集则是过去t内的访问过的所有页面.
  + **颠簸**: 每执行几个指令就发生缺页中断, 成为颠簸
  + 原理: 许多程序在运行时只需要调用很小一部分页面, 这些页面形成工作集, 可以设法跟踪这个工作集, 确保在进程运行前工作集已经调入到内存中, 这样可以极大减小缺页中断数, 加快运行.
  + 流程: 在置换时先检查每个页面的R位, 若为1, 表示被使用, 将当前时钟值写入时间位, 若为0, 则表示最近没被使用, 用当前时间减去他的时间位, 结果表示他的生存时间,若生存时间小于设定的t, 则置换掉, 若小于等于t, 则页面仍在工作集中, 此时就要记录生存时间最长的页面(即时间位最小的), 再找不到则选择R=0的, 若R都=0, 则选择干净一些的.
+ 工作集时钟算法:

  