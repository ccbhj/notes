# 微服务

1. ### 定义: 

   ### 微服务架构是一种架构风格，它将一个复杂的应用拆分成多个独立自治的服务，服务与服务间通过松耦合的形式交互

2. ### 特点:

   1. 单一职责: 每个服务都要满足单一职责原则, 一个服务本身是内聚的, 但是要按业务划分开来
   2. 自治: 一个微服务就是一个独立的实体, 可以部属升级, 服务之间通过REST, RPC等形式进行通信

3. ### 优点:

   1. 逻辑清晰: 单一职责带来的
   2. 简化部署: 一个服务可以独立部署
   3. 可拓展: 
   4. 灵活组合
   5. 技术异构: 兼容不同语言等等
   6. 高可靠性: 一个服务异常不会影响其他服务(除非有依赖, 此时可以熔断/隔离等)

4. ### 缺点:

   1. 复杂度高
   2. 运维复杂: 需要监控多个服务
   3. 影响性能: 交互方式为REST, RPC等形式, 受网络影响

5. ### API Gateway

   ![](/home/halo/notes/api_gateway.jpg)

   在客户端和各微服务之间，引入API Gateway为客户端(如android客户端/pc浏览器等)提供友好易用的接口，并将根据业务逻辑向各微服务实例请求。

   API Gateway可以是一个或多个；比如可以为Android和PC分别提供不同的API Gateway。同时，API Gateway自己本身也需要考虑扩缩容和负载均衡。API Gateway与各服务间可以采用融断等机制提高可靠性。

6. ### 服务的注册和发现:

   - **每个微服务通常有多个实例，每个实例具有不同的位置，而且实例会动态变化，比如在负载发生变化时服务会进行扩容或缩容，或者某个实例所在的VM/Container故障后发生迁移，都会导致服务实例地址的变化。**
   - 服务的所有实例在自己可以对外提供服务后，将位置注册到一个ServiceRegistry服务。这个服务具有**固定的位置或域名**，负责保存所有服务实例的位置信息。
   - 在使用ServiceRegistry时，服务实例要在无法提供服务时取消注册。ServiceRegistry需要通过心跳等方式核查出无法提供服务的实例，并将实例自动取消注册。
   - **服务注册有Self Registration和3rd Party Registration两种方式。Self Registration需要由每个服务实例自己实现服务的注册和取消注册的代码，3rd Party Registration则由第三方的Registrar完成服务的注册和取消注册。**
     - self registration: Self Registration需要由每个服务实例自己实现服务的注册和取消注册的代码
       - 服务实例能够更好的掌握注册时机，仅在真正可提供服务时才注册到ServiceRegistry
       - 所有服务都需要实现注册和取消注册代码，实现复杂且与ServiceRegistry有耦合；
       - 服务的实例很容易在不能提供服务时忘记取消注册；
     - **3rd Party Registration**:
       - 服务实例不需要负责服务的注册和取消注册，实现简单
       - 第三方的服务注册机制通常会提供健康检查机制判断注册的服务实例是否可用
       - 第三方的软件通常也需要进行部署和管理，增加了复杂度
       - 第三方的服务注册机制通常无法了解服务实例的实际状态
   - **客户端要使用服务必须通过服务发现技术获取服务的位置信息。服务发现包括Client-Side的服务发现和Server-Side的服务发现两种方式。**
     - 客户端发现:服务实例的发现由Client进行，发现的方式可以是主动到ServiceRegistry查询，也可以由ServiceRegistry通知到Client。
       - Client-Side Discovery相对于Server-Side Discovery有更少的跳数，性能更优。但所有类型的客户 端都需要实现服务发现与LB算法，客户端的复杂度高，且与ServiceRegistry耦合。
     - 服务端发现: 在Client和所有的服务实例间增加LoadBalance，Client只需要访问LoadBalance，由LoadBalance负责服务的发现和负载均衡。
       - Server-Side Discovery设计中，客户端只需要看到LoadBalance，复杂度低；如果是基于公有云提供服务，则公有云提供商通常会提供现成的服务端LoadBalance。但相对Client-Side Discovery增加了一跳，对性能有一定影响；同时LoadBalance的开发、部署、运维带来了额外的复杂度；
   
7. ### 服务熔断:

   1. #### 熔断: 当下游服务因某种原因变得不可用或者响应太慢时, 上游服务为了保证自己的可用性, 不再调用下游服务, 而直接返回, 快速释放资源.

      一般采用**断路器模式**, 如:

      ![](/home/halo/notes/断路器.jpg)

      1. 一开始处于closed状态, 然后当错误达到一定阈值时, 进入open状态, 开启熔断, 没有则重试

      2. 当熔断持续一段时间后(reset timeout), 进入half open状态, 尝试放行一部分请求, 若成功, 关闭熔断, 失败则回到open状态

      3. hystrix采用滑动窗口来统计每个时间片中相关的熔断计数指标和熔断器状态(bucket), 随着时间推移, 旧的bucket被丢弃, 新的被创建, 若每个bucket的请求中默认错误超过50%或一定时间内超过一定数量则需要进行熔断

      4. ### 服务隔离:

         做服务隔离的目的就是避免服务之间相互影响。毕竟谁也不能说自己的微服务百分百可用，如果不做隔离，一旦一个服务出现了问题，整个系统的稳定性都会受到影响

         1. 线程隔离: 每个依赖的服务申请线程池, 来处理存储当前请求, 并**设置超时**. 优点是可以应对突发流量, 缺点是每个服务的线程池有消耗
         2. 信号量隔离: 使用信号量来记录当前有多少个线程在运行, 请求, 线程超过一定数量就直接返回, 不继续请求下有服务.这样实现不了超时返回 

   2. #### 降级(fallback): 当下游服务过慢时, 下游主动停掉某些服务, 释放服务器资源, 增加响应速度, 避免卡顿, 以优先保证核心服务的运行

      ####  如何降级?

      1.  缓存: 如果实时依赖项不可用, 则直接从本地或远程检索缓存, 即使数据已经过期
      2. 最终一致性: 请求写入队列, 等到之后依赖的服务可用了再处理
      3.  返回默认值 
      4. 空响应: 可以返回null/空列表 

8. ### 限流:

   限流可作为服务降级的一种

   1. 漏桶算法:

      - 维护一个固定容量的漏桶(一般用队列来实现, 消息队列或者redis都可以)
      - 桶按固定的速度流出水滴(处理请求)
      - 桶盛住所有水(接住所有流量), 若超过阈值直接丢弃

   2. 令牌桶:

      - 以固定速率产生令牌, 放进一个固定容量的桶
      - 当n个请求进来时, 则取走n个令牌, 没法获得令牌的请求被丢弃

   3. 比较区别:

      1. 漏桶是出去, 令牌是进来
      2. 令牌桶可通过控制令牌产生速度控制处理速率, 漏桶不行
      3. 令牌产生与获取减慢处理速度

   4. nginx接入层限流:

      连接数限流模块ngx_http_limit_conn_module

      漏桶算法限流模块ngx_http_limit_req_module
