# 微服务

1. ### 定义: 

   ### 微服务架构是一种架构风格，它将一个复杂的应用拆分成多个独立自治的服务，服务与服务间通过松耦合的形式交互

2. ### 特点:

   1. 单一职责: 每个服务都要满足单一职责原则, 一个服务本身是内聚的, 但是要按业务划分开来
   2. 自治: 一个微服务就是一个独立的实体, 可以部属升级, 服务之间通过REST, RPC等形式进行通信

3. ### 优点:

   1. 逻辑清晰: 单一职责带来的
   2. 简化部署: 一个服务可以独立部署
   3. 可拓展: 
   4. 灵活组合
   5. 技术异构: 兼容不同语言等等
   6. 高可靠性: 一个服务异常不会影响其他服务(除非有依赖, 此时可以熔断/隔离等)

4. ### 缺点:

   1. 复杂度高
   2. 运维复杂: 需要监控多个服务
   3. 影响性能: 交互方式为REST, RPC等形式, 受网络影响

5. ### API Gateway

   ![](/home/halo/notes/api_gateway.jpg)

   在客户端和各微服务之间，引入API Gateway为客户端(如android客户端/pc浏览器等)提供友好易用的接口，并将根据业务逻辑向各微服务实例请求。

   API Gateway可以是一个或多个；比如可以为Android和PC分别提供不同的API Gateway。同时，API Gateway自己本身也需要考虑扩缩容和负载均衡。API Gateway与各服务间可以采用融断等机制提高可靠性。

6. ### 服务的注册和发现:

   - **每个微服务通常有多个实例，每个实例具有不同的位置，而且实例会动态变化，比如在负载发生变化时服务会进行扩容或缩容，或者某个实例所在的VM/Container故障后发生迁移，都会导致服务实例地址的变化。**
   - 服务的所有实例在自己可以对外提供服务后，将位置注册到一个ServiceRegistry服务。这个服务具有**固定的位置或域名**，负责保存所有服务实例的位置信息。
   - 在使用ServiceRegistry时，服务实例要在无法提供服务时取消注册。ServiceRegistry需要通过心跳等方式核查出无法提供服务的实例，并将实例自动取消注册。
   - **服务注册有Self Registration和3rd Party Registration两种方式。Self Registration需要由每个服务实例自己实现服务的注册和取消注册的代码，3rd Party Registration则由第三方的Registrar完成服务的注册和取消注册。**
     - self registration: Self Registration需要由每个服务实例自己实现服务的注册和取消注册的代码
       - 服务实例能够更好的掌握注册时机，仅在真正可提供服务时才注册到ServiceRegistry
       - 所有服务都需要实现注册和取消注册代码，实现复杂且与ServiceRegistry有耦合；
       - 服务的实例很容易在不能提供服务时忘记取消注册；
     - **3rd Party Registration**:
       - 服务实例不需要负责服务的注册和取消注册，实现简单
       - 第三方的服务注册机制通常会提供健康检查机制判断注册的服务实例是否可用
       - 第三方的软件通常也需要进行部署和管理，增加了复杂度
       - 第三方的服务注册机制通常无法了解服务实例的实际状态
   - **客户端要使用服务必须通过服务发现技术获取服务的位置信息。服务发现包括Client-Side的服务发现和Server-Side的服务发现两种方式。**
     - 客户端发现:服务实例的发现由Client进行，发现的方式可以是主动到ServiceRegistry查询，也可以由ServiceRegistry通知到Client。
       - Client-Side Discovery相对于Server-Side Discovery有更少的跳数，性能更优。但所有类型的客户端都需要实现服务发现与LB算法，客户端的复杂度高，且与ServiceRegistry耦合。
     - 服务端发现: 在Client和所有的服务实例间增加LoadBalance，Client只需要访问LoadBalance，由LoadBalance负责服务的发现和负载均衡。
       - Server-Side Discovery设计中，客户端只需要看到LoadBalance，复杂度低；如果是基于公有云提供服务，则公有云提供商通常会提供现成的服务端LoadBalance。但相对Client-Side Discovery增加了一跳，对性能有一定影响；同时LoadBalance的开发、部署、运维带来了额外的复杂度；