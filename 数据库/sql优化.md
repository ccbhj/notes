# sql优化

1. ## explain

   1. id: 执行顺序, id大的先执行, 一样大的上面先执行

   2. #### select_type: 查询类型:

      - **SIMPLLE**：简单查询，该查询不包含 UNION 或子查询

      - **PRIMARY**：如果查询包含UNION 或子查询，则**最外层的查询**被标识为PRIMARY

      - UNION：表示此查询是 UNION 中的第二个或者随后的查询

      - DEPENDENT：UNION 满足 UNION 中的第二个或者随后的查询，其次取决于外面的查询
      - UNION RESULT：UNION 的结果
      - **SUBQUERY**：子查询中的第一个select语句(该子查询不在from子句中)
      - DEPENDENT SUBQUERY：子查询中的 第一个 select，同时取决于外面的查询
      - **DERIVED**：包含在from子句中子查询(也称为派生表)
      - UNCACHEABLE SUBQUERY：满足是子查询中的第一个 select 语句，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中
      - UNCACHEABLE UNION：满足此查询是 UNION 中的第二个或者随后的查询，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中

   3. table: 正在访问哪个表

   4. #### type: 该列称为**关联类型或者访问类型**(判断性能的重要依据)

      - ALL: 全表扫描
      - index: 全索引扫描(。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要少很多。)
      - range: 范围扫描(经常出现有<, >, <>, =)
      - ref: 索引访问, 访问匹配单个值的行, 多出现在多表的join里面
      - eq_ref: 最多返回一条记录, 多出现在唯一索引和主键的查找上
      - const, system: 最多一个匹配行, system表明在访问系统表, const用于主键或者唯一索引有固定值比较的情况
      - NULL: 不需要访问表

   5. possible_keys: 显示查询**可能**使用哪些索引来查找

   6. #### key:  当前用的哪个索引, 可能为NULL

   7. key_len: 索引的字节数(当text/blob为索引时必须指定)

   8. ref: 哪些字段或者常量被用来和key配合从表中查询记录出来

   9. rows: 估计了要读取的行数

   10. extra: 其他信息:

       - **Using index**：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。

       - Using Where：在存储引擎检索行后再进行过滤，使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户。

       - Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。

       - Using filesort：对结果使用一个外部索引排序，而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大。

2. ### 覆盖索引:

   **当查询列出现在索引中, 不用回表**

3. ### 联合索引

4. ### 最左匹配原则:

   -  索引以区分度高的列开头
   - 避免对索引使用范围查询

5. ### 索引下推(5.6+版本):

   当有like查询时, 对联合索引来说, 当匹配到like条件时, 可以再匹配后面的条件以进行过滤, 而不用一个个去回表匹配后面的条件

6. ### change buffer:

   当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，**这样就不需要从磁盘中读入这个数据页了。**

   在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性, 同时不用每次都读盘. 后台线程会定期合并内存的change buffer和磁盘页

   **对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。要判断表中是否存在这个数据，而这必须要将数据页读入内存才能判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。所以只有普通索引可以用**

   change buffer用的是buffer pool里的内存，因此不能无限增大，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置，这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。

7. ### 前缀索引:

   当索引为较长的字符串时, 可以指定字符串作为索引的长度, 既节省空间又减少查询成本.

8. ### 避免在条件字段用函数操作:

   此时用不上索引, 但是可以对常数进行控制

9. ### 隐式类型转换:

   select * from t where id = 1

   如果id是字符类型的，1是数字类型的，你用explain会发现走了全表扫描，根本用不上索引，为啥呢？

   因为MySQL底层会对你的比较进行转换，相当于加了 CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引。

10. #### 隐式字符编码转换:

    还是一样的问题，如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。

11. ### flush刷脏页:

    修改后的在内存中的数据页被成为脏页, 此时这个页就需要刷到硬盘以持久化, 在:

    - redo log写满时, 需要停止所有操作, 把checkpoint往前推进
    - 系统内存不够, 需要淘汰一些脏页

    通过innodb_io_capacity参数, 设置刷脏页的速度

    通过innodb_flush_neighbors=0, 禁止连带附近脏页也给刷盘

12. ### 数据表结构优化:

选择合适的数据类型:

- 选数据大小较小的(根据业务)
- 选简单的, 能选int不选varchar
- 添加not null熟悉(null字段处理麻烦)
- 少用text, 要用的话尽量分表

13. ### Prepare Statement

    - 可以检查绑定的变量, 防止sql注入
    - mysql只会解析prepare语句, 性能高
    - 二进制编码, 提高网络传输效率
    - **注意不支持查询缓存**
    - 