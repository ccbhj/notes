# 进程间通信(IPC)

1. ### fork:
    1. 由fork创建的新进程被称为子进程（child process）。**该函数被调用一次，但有两个返回值。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程id。**将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。
    2. 操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，**这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的）**
    3. 子进程和父进程共享代码段, 数据段使用Cow
3. 所有进程都是都是从pid=0的内核线程(数量与cpu核相同), 或者pid=1的init进程fork出来的
   
2. ### 匿名管道(pipe):
管道是一种半双工的通信方式，**数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。通过内核缓冲区实现数据传输**

3. ### 有名管道通信 (FIFO)：
有名管道也是半双工的通信方式，**但是它允许无亲缘关系进程间的通信。，在磁盘上有对应的节点，但没有数据块——换言之，只是拥有一个名字和相应的访问权限，** 通过mknode()系统调用或者mkfifo()函数来建立的。有名和无名管道的主要区别在于，命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。 也是通过内核缓冲区实现数据传输

5. ### 消息队列通信( message queue ):
    1. 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。**消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。**
    2. 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
    3. 可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。

6. ### 信号量通信( semophore ):
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

7. ### 信号(signal)
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

8. ### 共享内存通信( shared memory ): 
    1. 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
    2. **共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。**
    3. 对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。
    4. 共享内存有两种实现方式：
        1. 内存映射: 内存映射 memory map机制使进程之间通过映射同一个普通文件实现共享内存，通过mmap()系统调用实现。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read/write等文件操作函数
        2. 共享内存机制: UNIX system V共享内存是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信

9. ### 套接字通信( socket )：
套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
