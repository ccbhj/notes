# Linux 内存管理

1. ### 进程地址空间被分为3个段

   1. 代码段: 不可变的代码指令
   2. 数据段: 所有程序变量, 有两个部分, 初始化的(DATA)和未初始化数据(BSS). 初始化变量为编译期常量, BSS是在加载后才被初始化为0.
   3. 堆栈段: 从虚拟地址顶部开始, 向下的低地址空间增长(在32位机器上, 栈空间从0xC0000000开始, 高地址的1G为内核空间, 留给页表或者其他内存数据)

   - 0地址被初始为一个带写保护的内存页, 所以空指针值为0, 当对这块页进行写时, 会报错.
   - 64位机器上, 只有48位用于寻址, 所以地址空间为256TB, 用户, 内核空间各占一半
   - 当进程被创建时, 地址空间被创建, 当一个exec系统调用发生时进行重写

2. ### 物理空间管理

   1. linux区分以下3个地址区域(物理地址是从低到高的, 内核是在底地址, 而用户空间地址的内核空间是在高地址的, 所有映射时需要加3G):

      - ZONE_DMA和ZONE_DMA32(0-16MB): 用于DMA的页(DMA32是为了兼容32位的设备), 小于16MB

      - ZONE_NORMAL(16-896MB): 正常的, 用于映射内核页, 可直接映射(如加上在32位上的3G偏移就行)

      - ZONE_HIGNMEM(896MB-4G): 高内存地址页, 不永久映射, 内核无法直接映射的区(因为内核内存空间和用户空间地址比1:3, 内核无法1:1的获取用户空间[像上面的ZONE_NORMAL], 只能通过一段一段的映射用户地址空间), 需要动态映射

   2. linux内存为以下3部分组成:

      1. 内核映射(从不换出换入)
      2. 内存映射(从不换出换入)
      3. 页框(用于虚拟内存交换)

   3. 内核维护管理物理内存:

      1. 内核维护一个页描述符数组,  成为mem_map, 其中页为page类型, 每个物理页框对于一页, 页中保存着它对应的被映射的虚拟内存的指针(如果非空闲的话), 还有前后指针以连成链表
      2. 内核还维护一个空闲链表free_area, 第i项代表2^i个空闲页的第一个块的描述符指针

   4. Linux采用4级分页策略,也可以变为3级

      全局目录+上级目录(3级页面就将此目录大小设为0)+中间目录+页面+偏移 = 虚拟地址

   5. 内核自身完全是硬连线的, 永远不换出, 其余用于虚拟内存交换

   6. **分配算法**:

      1. 伙伴算法:

         一片内存被二分, 若可以满足需求, 则进行分配, 若不行, 则二分低片段, 重复, 直到找到适合的大小的块. 

         当释放内存时, 则合并它的伙伴(另一个高片段)

         **这个算法可以很容易找到2的幂次大小块, 但造成许多碎片, 因为你想要一个65大小的块, 必须分配一个128大小的块, 于是引入slab**

      2. slab分配器:

         **用于分割伙伴算法分配的大块内存**

         因为内存频繁的创建和撤销一样的类型的对象, 所以使用了**对象缓存**. 这些缓存由指向一个或多个slab分配器的指针组成, 而slab可以存储大量的相同类型的对象. 如task_struct有自己的slab缓存, 当需要分配一个进程时, 先去其缓存找, 如果没有就去空闲列表找, 最后再不行就自己创建一个

      3. vmalloc:

         用于分配连续的虚拟地址, 不用于物理内存

3. ### 虚拟空间管理:

   1. 在内核中, **虚拟空间被划分为同构页面(物理页)对齐的区域, 也就是说是一组联系的具有相同读写保护和分页属性的页面组成. ** 是内核管理虚拟内存的最小单位

   2. 由vm_area_struct表示, 所有vm_area_struct按虚拟地址大小用链表组织起来, 当链表太长时, 建树. 此结构记录了内存页面是否有读写保护, 是否固定在内存中, 朝哪个方向增长, 是否在硬盘上有备份,

   3. fork时, 父进程的vm_area_struct链表被复制到子进程, 但让父子进程指向相同的页表(CoW). **子进程的区vm_area_struct为可读/写, 但页却是只读,  当子进程尝试写时, 内核会发现这页不可写, 于是复制父进程的页, 并标记为可读写**

   4. 顶层描述符mm_struct用于描述一个进程的整个地址空间的信息, 还有不同段和用户共享地址空间的信息

   5. **进程的泄漏的内存会被os释放吗? **

      每个进程有他自己的虚拟内存空间(address_space), 堆空间申请, mmap等等操作都是在虚拟地址空间上进行的, 当进程结束时, 整个内存地址空间会被销毁, 所以内存泄漏不会持续到进程后. **除非内存是申请在内核里的, 或者使用了共享内存**

4. #### Linux分页:

   1. 为了运行, 一个进程并不需要完全在内存中, 实现上需要的只是**用户结构(task_struct)和页表**
   2. 分页由页面守护进程进行, pid为2(进程1为init, 进程0为idle进程)
   3. 代码段和映射文件换页到他们各自的磁盘文件, 其他段被换到交换分区 