# HTTP

1. ### HTTP的特点

   1. 超文本传输协议 -- **H**yperText **T**ransfer **P**rotocol。
   2. 明文传输
   3. 面向报文
   4. 无状态
   5. 端口:80

2. ### URI(统一资源定位符):

   有以下两种形式

   1. URL(统一资源定位器):**它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。**

      格式:`<协议>://<用户名>:<密码>@主机:端口/路径?参数1&参数2#片断`

      + ①协议(或称为服务方式)
      + ②存有该资源的主机IP地址(有时也包括端口号)
      + ③主机资源的具体地址。如目录和文件名等

   2. URN(统一资源名): **统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。**

3. ### HTTP状态码:

   ![](/home/halo/notes/http状态码.jpg)

- 100(Continue):  服务端已收到请求头, 客户端需要继续发送请求体

- 101( Switching Protocols):  切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议

- 200: OK

- 201(Created): 已创建。成功请求并创建了新的资源, 且其URI在响应的Location字段中

- 202(Accepted): 已经接受请求, 但未处理

- 204(No Content): 已经成功处理请求, 但是没有返回任何内容

- 301(Moved Permanently)：永久性重定向, 新的URI在Location字段中(可缓存的)

- 302(Found)：临时重定向, 客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

- 304(Not Modified):  表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。

- 400(Bad Request)：请求报文错误(语法错误, 请求太大,)，服务器无法识别

- 401(Unauthorized): 未认证

- 403(Forbidden):  服务器已经理解请求, 但是拒绝执行, 禁止访问

- 404(Not found): 找不到资源

- 405(Method Not Allowed): 某个请求所针对的资源不支持对应的请求方法, 并在Allow字段中附上可以获取此URI的请求方式

- 500: 服务器内部错误

- 501(Not Implement): 服务器不认识或者不支持对应的请求方法

- 502:  Bad Gateway, 作为[网关](https://zh.wikipedia.org/wiki/网关)或者[代理](https://zh.wikipedia.org/wiki/代理服务器)工作的服务器尝试执行请求时，从上游服务器接收到无效的响应

- 503: 服务器忙(临时维护或者过载)

  

4. ### 报文格式:

   <img src="/home/halo/notes/http报文头.jpg" style="zoom:150%;" />

   - 请求:  
     1. 起始行: **方法   \s  路径URL  \s  协议版本 **
     
     2. 首部字段:  可以有0个或多个首部, 以键值对形式, 每个键值对以**CRLF(空行)**结束.
     
     3. 请求体: 首部与请求体之间以CRLF隔开
     
        

   ![](/home/halo/notes/响应报文.png)

   

   - 响应:
     1. 起始行: 版本  \s  响应状态码  \s  描述信息
     2. 首部字段: 同请求首部字段一样
     3. 响应体

5. ### 请求方法:

   1. GET: 用于请求服务器的某个资源
   2. POST: 用于向服务器传输数据
   3. HEAD: 与get类似, 不过服务器只返回首部
   4. PUT: 将文件传输给服务器, 并存入对应的URI位置
   5. TRACE: 用于在服务器发起环回诊断
   6. OPTIONS: 返回服务器支持的服务或HTTP方法
   7. DELETE: 删除服务器的某个资源

6. POST与GET的区别:

   1. GET用于获取资源(幂等), POST用于创建/更新资源(非幂等)
   2. **GET产生一个TCP数据包；POST产生两个TCP数据包。 ** POST的第一个数据包先发送header, 服务器响应100, 然后再发送数据.
   3. GET产生的URL地址可以被记录，而POST 不可以。
   4. **GET请求会被浏览器主动cache，而POST不会，除非手动设置。**
   5. GET请求只能进行url编码，而POST支持多种编码方式。
   6. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
   7. GET请求在URL中传送的参数是有长度限制的，而POST没有。
   8. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
   9. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息.
   10. **GET参数通过URL传递，POST放在Request body中。**

7. 常见首部字段:

   1. 通用首部:

      + Date: 报文日期
      + Keep-Alive: 是否开启持久连接 
   
      + Connection：连接的管理
   + Cache-Control：缓存的控制
      + Transfer-Encoding：报文主体的传输编码方式
   
   2. **请求首部字段（请求报文会使用的首部字段）**:
   
      1. Content-Type: 报文主体的对象类型
      2. Accept: 用户代理可处理的媒体类型
      3. Authorization: Web认证信息
      4. If-Modified-Since: 比较资源的更新时间
      5. If-None-Match: 比较实体标记
      6. Referer: 从哪个页面进行请求
      7. User-Agent: http客户端的信息
   
   3. 响应首部:
   
      1. Location: 用于重定向
      2. Proxy-Authenticate: 代理服务器对客户端的认证信息
      3. Server: HTTP服务器的安装信息
   
   4. 实体字段(用于补充说明实体的信息):
   
      1. Allow: 资源支持的HTTP方法
      2. Content-Encoding:资源编码类型
      3. Expires: 实体过期的日期
      4. Content-Length: 资源长度 
8. HTTP 1.1 新特性

   + 缓存处理(cache-control)
   + 带宽优化及网络连接的使用(keep-alive)
   + 错误通知的管理
   + 消息在网络中的发送
   + 互联网地址的维护(host)
   + 安全性及完整性

   1. keep-alive持久连接(1.1默认特性):

      - 每次http请求都会进行一次TCP握手,  同时一个网页除了页面的HTML之外还会有很多静态资源以及诸多的API调用，如果每个请求都一个连接，势必网页的一次加载就会和服务器创建多次连接，这是非常浪费服务器资源的，同时也让客户端的访问速度慢了不少。
      - 持久连接也不宜一直保持，毕竟每个连接都会占用服务器资源，如果打开网页的人太多，那服务器资源也会紧张，所以一般服务器都会配置一个KeepAlive Timeout参数和KeepAlive Requests参数限制单个连接持续时长和最多服务的请求次数。

   2. Pipeline管道化:

      HTTP1.0不支持管线化，同一个连接处理请求的顺序是逐个应答模式，处理一个请求就需要耗费一个TTL，也就是客户端到服务器的往返时间，处理N个请求就是N个TTL时长。当页面的请求非常多时，页面加载速度就会非常缓慢。

      可以同时将多个请求发送到服务器，然后逐个读取响应。这个管线化和Redis的管线化原理是一样的，响应的顺序必须和请求的顺序保持一致。

   3. 断点续传:**实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。**

9. HTTP/2:

   1. 多路复用:

      浏览器对同一域名下的并发连接数量有限制，一般为6个, 而HTTP2的请求与响应以二进制帧的形式交错进行，只需建立一次连接，即一轮三次握手，实现多路复用。

   2. 压缩消息头:

      HTTP1的消息头很大冗余，而HTTP2.0利用HPACK对消息头进行压缩传输，将常用的消息头用索引(两端共同维护的静态表[存储常见头部名和头部]和动态表)表示, 即是将消息头中的不同的部分分别用不用的索引进行表示，且会用**哈夫曼编码压缩字符串**，最后封装成frame。索引表分为动态索引和静态索引，动态索引表在客户端和服务器端共同维护，静态索引采用硬编码形式。

   3.  HTTP2.0服务端推送

      HTTP2.0中服务器会主动将资源推送给客户端，例如把js和css文件主动推送给客户端而不用客户端解析HTML后请求再响应
      
   4. 二进制分帧

      在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。

10. ## HTTPS:

    1.  要解决的问题:

       - HTTP明文传输, 不安全
       - 传输内容可能被篡改
       - 通信双方可能被伪装

    2. TLS/SSL层(安全传输层): 传输层安全, 位于会话层

    3. 端口: 443

    4. 加密方式: 混合加密, 用非对称加密传输密钥, 用对称加密传输内容

    5. 数字证书: 解决了双方的身份的验证问题, 客户端很少有交换证书. 获取步骤:

       1. 服务器向认证机构发送自己的公钥
       2. **认证机构用机构的私钥对服务器公钥进行数字签名生成了数字证书发送给服务器**
       3. 客户端有了证书后可以用证书机构的公钥来验证服务器公钥的真实性

    6. 握手:

       1. 客户端服务器相互发送hello报文, 交换ssl版本号,加密算法等
       2. 服务器发送数字证书与公钥(第一次握手结束)
       3. 客户端用证书机构的公钥对证书进行验证, 验证成功后生成随机密码串(Pre-master secret)同时用服务器公钥签名并发给服务器
       4. 最后客户端发送Finished报文, 这次报文包含全部报文的整体校验值, 服务器必须能解密此报文才能算握手成功.
       5. 之后的每次http报文都要用随机密码串进行加密
       6. 报文附加上MAC(Message Authentication code 消息认证码), 以检查报文有无被篡改

    7. 缺点:

       - 处理速度变慢, 因为每次传输都要加密, 消耗资源
       - 证书不便宜
       - 证书机构可能会被黑

       

    